Low level tracepoint handler templates (ARM Architecture)
---------------------------------------------------------

When a tracepoint is hit, the program executes a special low-level tracepoint
handler.  This handler executes the following steps:
	1. Store the processor state (by pushing registers to the stack);
	2. Initialize parameters for the high-level handler;
	2. Call the high-level handler (the handler defined in the injectable);
	3. Restore the register state;
	4. Execute the original instruction out-of-line;
	5. Jump back to the instruction following the tracepoint.

The above steps are usually the same in most cases, except for step 4.  In step
4, the handler has to execute the original instruction or, if this is not
possible directly, execute a set of instructions, which will have the same
effect as the original instruction.  

Because of different types of traceable instructions, the low-level handlers
need to be generated by ADBI Server during runtime.  These handlers are
generated from templates -- small fragments of binary code (compiled from
regular ARM assembly source files) with special information, which describes
how the template should be modified (filled out) to make it work.

Handler templates are written in pure ARM assembly.  The files are then
compiled into object files.  After that, a special Python script, t2c,
converts them to C code, which is compiled into ADBI Server. 

Information about how to use the template is encoded in symbol names. All
symbol names, which start with a "tf_" prefix have a special meaning to the
t2c script.  The addresses of these symbols are stored in the C source file
and marked with the appropiate "TF_" enum value defined in "templates.h".
Additionally, if a symbol starts with "tf_" and ends with a decimal number,
the number is discarded before conversion to an enum  (e.g. tf_qux123 will be
translated to TF_QUX).

For example, consider the following snippet of assembly:
		.text
		.arm
	foo:
		push {fp, ip, lr}
	tf_bar:
		add r0, r1, #42
		pop {fp, ip, pc}
	
The above code has 2 symbols defined.  The first symbol, "foo", has no meaning
to the t2c script.  The second symbol, "tf_bar", will be captured by t2c --
the script will store information, that the location at the offset of tf_bar
(probably 0x04 in the above case), needs to be modified in the way defined by
the TF_BAR enum value. 

There TF_ enum values are documented in the code.  However, it may be useful
to remember some nameing conventions:
	* Enums starting with TF_PATCH_ do not replace the following
	  instructions, but patch them by replacing only selected bits.
	* Enums starting with TF_THUMB_ and TF_ARM_ cause insertion of a
	  32-bit value, which was encoded in the original instruction directly
	  (as an immediate value). These fields are usually used by only one
	  instruction of only one kind, the names follow the pattern
	  TF_KIND_INSN.
	* Other enums insert a 32-bit value (usually for use as a literal) and
	  are generic (used in both ARM and Thumb code).
	* Enums which contain a instruction name, can additionally have a
	  number postfix, which specifies the instruction encoding variant, 
	  which matches the number in the ARMv7 documentation.

The TF_PATCH_ enum names, which describe which parts of the instructions they 
change.  The names have been chosen to match typical instruction opcodes.
However, some opcodes use special encodings, so the instructions must be
marked very carefully when using TF_PATCH enums/symbols. 

The lists below describe the mapping of symbolic names to affected opcode
bits.

ARM:
	* COND 	condition field 	bits 28-31
	* RD 	destination register 	bits 12-15
	* RN 	first operand register 	bits 0-3
	* RM 	second operand register	bits 16-19

Thumb:
	* COND 	condition field (only for conditional branch) -- bits 24-27
	* RD 	destination register 	bits 9-11
	* RN	first operand register	bits 0-2
	* RM	second operand register	bits 3-5
	* HRN	first operand register (high)	bits 0-2 and bit 8
	* HRM 	second operand register (high)	bits 3-6



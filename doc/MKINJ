MKINJ 
-----

mkinj is a Python script, which allows to produce injectable files from .adbi script files.  It was designed to allow 
injectable creation simpler, in just one step.  However, mkinj internally calls several tools in order which process 
the file step by step.  This document describes these steps briefly as well as mkinj usage.


Overview
--------

An injectable is generated by mkinj in four steps:

    1.  The .adbi script file is the input file written by the user.  The .adbi script is a C source file, which uses
        a few additional preprocessor directives.  This file can be converted to a pure C file using another script 
        called adbipp.  adbipp reads the file line by line looking for lines starting with a hash (#).  Then it checks
        if the word after the hash is a ADBI directive.  If this is the case, it processes the directive accordingly by
        writing proper C code fragments to the output stream.  In all other cases (regular code or C directives) it 
        simply copies the line to the output stream.  As a result, a C source file is created.  It should be noted that 
        for correct recognition of preprocessor directives, adbipp first strips all C and C++ comments from the file, so
        the result C file has no comments.

    2.  The C source is compiled using GCC.  mkinj calls the compiler with a set of special command line switches, but 
        besides this step is pretty simple.  The result of this step is an object file (.o).

    3.  The .o file is linked using the binutils linker LD.  Linking done using a custom linker script.  All .data and 
        .text sections of the file are merged together into one .adbi section.  The result section will become the part
        of the injectable, which will eventually be injected into the traced processes.  The result of this step is 
        an injectable-object file (.io).  This file may still have .debug sections with DWARF information, which can be
        used for debugging. 

    4.  The .io file is converted to the final .inj injectable file.  This is done by another helper script called inj.
        The script simply copies parts of the original .io ELF file, stores symbols, tracepoint addresses etc. 


The mkinj script is only a tool, which performs the above steps in order by calling the right tools with the right 
arguments.  

Usage
-----

    mkinj [-h] [--action {preprocess,compile,link,injectable}]
          [--output OUTPUT] [--binary BINARY] [--library LIBRARY]
          [--comment COMMENT] [--input-type {adbi,c,o,io,auto}]
          [--sysroot dir] [--gcc GCC]
          input

The only required parameter is the input file path, which can be an ADBI script (.adbi), a C source file (.c) or an 
injectable object (.io).  The type of input is determined by the extension.  All other parameters are optional:
  --action {preprocess,compile,link,injectable}
  -a       {preprocess,compile,link,injectable}
                        Specifies what output should be produced.  By default, mkinj performs the steps required to
                        produce an injectable.  For .adbi scripts it will perform all four steps, for .c files the last 
                        three, etc.  This switch allows to change this behavior. 
  --output OUTPUT
  -o OUTPUT
                        Sets the output file path to OUTPUT.  If this option is not used, the name of the input file 
                        is used, with extension changed to .c, .o, .io or .inj.
  --binary BINARY       
                        Specifies the binary, which will be linked with this injectable (so the result injectable will 
                        contain tracepoints in the binary BINARY).  This is not required if the .adbi file contains a 
                        #binary directive.  The path should be a path to a valid binary on the device, not on the local
                        system.  This option can not be used together with --library.
  --library LIBRARY
  -l LIBRARY
                        Produce a library injectable named LIBRARY.  Library injectables are not bound to a binary and 
                        don't define any tracepoints.  They are just collections of exported functions, visible to other
                        injectables.  This is currently used for built-in injectables, it is an advanced feature.  
                        This option can not be used together with --binary.

  --comment COMMENT     
                        Allows to include the given COMMENT in the result injectable.  The comment has no meaning to 
                        adbiserver, it is just a way to mark injectables or add arbitrary, human readable messages and
                        comments to them.  If omitted, COMMENT is set to a default string.  To not include a comment, 
                        use --comment "" 
  --input-type {adbi,c,o,io,auto}
  -i {adbi,c,o,io,auto}
                        The type of the input file is by default determined by the extension, but this behavior can be 
                        overriden by this parameter.  
  --sysroot DIR         
                        Use DIR as the logical root directory for binaries.  This directory is used as a local copy of 
                        the root file system on the device.  adbipp will look for a file specified by the --binary 
                        parameter or the #binary directive treating DIR as the root directory.  The local copy of the 
                        file is used for reading DWARF information about the binary.
  --gcc GCC 
  --compiler GCC
  --cc GCC
                        Specifies the path to the GCC, which should be used in the compilation step.  If this option is
                        not specified, the GCC path is read from the following environment variables in order: ADBICC,
                        GCC, CC.  If none of these variables is set and no compiler is set on the command line,  mkinj
                        tries to use arm-linux-androideabi-gcc.


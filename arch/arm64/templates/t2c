#!/usr/bin/python
# -*- coding: utf-8 -*-
import subprocess
import re
import sys
import os
import argparse
import hashlib

AUTOGENERATED_WARNING = 'Warning!  This file was generated automatically.'

################################################################################

def iter_text(filename):
    '''Yield all bytes of the text section.'''
    def get_text_section_location(filename):
        '''Get text section offset and size (tuple).'''
        REGEX = re.compile('''\\[\\s*[0-9]+\\]\\s+\\.text\\s+PROGBITS\\s+([0-9a-fA-F]+)\\s+([0-9a-fA-F]+)\\s+([0-9a-fA-F]+).*''')
        for line in subprocess.check_output([READELF, '-S', '-W', filename]).split('\n'):
            match = REGEX.match(line.strip())
            if match:
                return int(match.group(2), 16), int(match.group(3), 16)
        raise ValueError('Error extracting .text section information from {:}.'.format(filename))

    offset, size = get_text_section_location(filename)
    with open(filename, 'rb') as f:
        f.seek(offset)
        for n in xrange(size):
            yield ord(f.read(1))


def iter_symbols(filename):
    REGEX_SYMS = re.compile('''[0-9]+:\\s+([0-9a-fA-F]+)\\s+[0-9]+\\s[A-Z]+\\s+[A-Z]+\\s+[A-Z]+\\s+[0-9]+\\s+(.+)''')
    for line in subprocess.check_output([READELF, '-s', '-W', filename]).split('\n'):
        match = REGEX_SYMS.match(line.strip())
        if match and not match.group(2).startswith('$') and match.group(2).strip():       
            yield match.group(2).strip(), int(match.group(1), 16)

################################################################################

def write_template(filename):
    
    def location(addr):
        cmd = [ADDR2LINE, '--exe=%s' % filename, hex(addr)]
        f, l = subprocess.check_output(cmd).strip().split(':', 1)
        return f, int(l)
    
    def write_array(bytes):
        OUT.write('static unsigned char %s_bin[] = {' % name)
        for i, byte in enumerate(bytes):
            if i % 16 == 0:
                OUT.write('\n    /* 0x%02x */  ' % i);
            OUT.write('0x%02x, ' % byte)
        OUT.write('\n};\n\n')
    
    def write_fields(symbols):
        OUT.write('static template_field_t %s_sym[] = {\n' % name)
        for symbol, addr in sorted(symbols, key=lambda x: (x[1], x[0])):
            symbol = symbol.strip().upper()
            while symbol and symbol[-1].isdigit():
                symbol = symbol[:-1]
            if symbol[-1] == '_':
                symbol = symbol[:-1]
            file, line = location(addr)
            OUT.write('#line %i "%s"\n' % (line, file))
            OUT.write('    { %s, 0x%02x },\n' % (symbol, addr))
        OUT.write('    { TF_NULL, 0 },\n')
        OUT.write('};\n\n')
    
    bindata = list(iter_text(filename))
    
    all_syms = list(iter_symbols(filename))
    
    symbols = [(name, addr) 
               for (name, addr) 
               in all_syms
               if name.lower().startswith('tf_')]
    
    poolat = dict(all_syms).get('constants', len(bindata))
    
    name = PREFIX + os.path.splitext(os.path.basename(filename))[0]

    write_array(bindata)
    write_fields(symbols)

    OUT.write('template_t %s = {\n' % name)
    OUT.write('    { 0x%02x, %s_bin },\n' % (len(bindata), name))
    OUT.write('    %s_sym,\n' % name)
    OUT.write('    "%s",\n' % os.path.splitext(os.path.basename(filename))[0])
    OUT.write('    0x%02x,\n' % poolat)
    OUT.write('};\n\n')



################################################################################

def generate_src(inputfiles):
    OUT.write('/* {:} */\n'.format(AUTOGENERATED_WARNING))
    OUT.write('#include "tracepoint/template.h"\n')
    for filename in sorted(inputfiles):
        write_template(filename)
       

def generate_head(inputfiles):
    guard = 'GUARD_' + ''.join('%02x' % ord(x) for x in hashlib.md5(' '.join(inputfiles)).digest()).upper()
    OUT.write('/* {:} */\n'.format(AUTOGENERATED_WARNING))
    OUT.write('#ifndef {:}\n'.format(guard))
    OUT.write('#define {:}\n\n'.format(guard))
    OUT.write('struct template_t;\n')
    OUT.write('typedef struct template_t template_t;\n\n')

    for filename in sorted(inputfiles):
        symbol_name = PREFIX + os.path.splitext(os.path.basename(filename))[0]
        OUT.write('extern template_t {:};\n'.format(symbol_name))            

    OUT.write('\n#endif /* {:} */\n'.format(guard))

parser = argparse.ArgumentParser(description='Convert a binary object file to a C array.')
parser.add_argument('input', type=str, help='input file name', nargs='+')
parser.add_argument('--output', '-o', type=str, help='output file name', default='templates.c')
parser.add_argument('--header', '-H', action='store_true', help='generate a header file')
parser.add_argument('--readelf', '-r', type=str, help='path to readelf binary', default='readelf')
parser.add_argument('--addr2line', '-a', type=str, help='path to addr2line binary', default='addr2line')
parser.add_argument('--prefix', '-p', type=str, help='symbol name prefix', default='template_')

args = parser.parse_args()

READELF = args.readelf
ADDR2LINE = args.addr2line
PREFIX = args.prefix

with open(args.output, 'w') as OUT:
    if args.header:
        generate_head(args.input)
    else:
        generate_src(args.input) 

